package cn.superiormc.mythictotem.objects;

import cn.superiormc.mythictotem.MythicTotem;
import cn.superiormc.mythictotem.libreforge.LibreforgeEffects;
import cn.superiormc.mythictotem.managers.BonusEffectsManager;
import cn.superiormc.mythictotem.managers.ConfigManager;
import cn.superiormc.mythictotem.managers.ErrorManager;
import cn.superiormc.mythictotem.objects.checks.ObjectPlaceCheck;
import cn.superiormc.mythictotem.objects.effect.AbstractEffect;
import cn.superiormc.mythictotem.objects.effect.EffectStatus;
import cn.superiormc.mythictotem.objects.effect.EffectUtil;
import cn.superiormc.mythictotem.objects.singlethings.BonusTotemData;
import cn.superiormc.mythictotem.utils.TextUtil;
import org.bukkit.block.Block;
import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.Player;

import java.util.*;

public class ObjectTotem {

    // 图腾的行和列
    private int totemRow;

    private int totemColumn;

    private int totemLayer;

    // 图腾各处的方块
    // 行列，Material
    private final Map<String, String> totemLocationMaterial = new HashMap<>();

    private final ObjectAction totemAction;

    private final ObjectCondition totemCondition;

    private ObjectAction bonusEffectApplyActions;

    private ObjectAction bonusEffectRemoveActions;

    private ObjectAction bonusEffectCircleActions;

    private final List<String> totemCoreBlocks;

    private final boolean totemDisappear;

    private final boolean totemBonusEffects;

    private final String totemCheckMode;

    private final ConfigurationSection totemSection;
    
    private final String totemID;

    private final Map<UUID, EffectStatus> mmoEffects = new HashMap<>();

    public ObjectTotem(String id, YamlConfiguration section) {
        this.totemID = id;
        this.totemDisappear = section.getBoolean("disappear", true);
        this.totemAction = new ObjectAction(section.getConfigurationSection("actions"));
        this.totemCondition = new ObjectCondition(section.getConfigurationSection("conditions"));
        this.totemCheckMode = section.getString("mode", "VERTICAL").toUpperCase();
        this.totemCoreBlocks = section.getStringList("core-blocks");
        this.totemBonusEffects = section.getBoolean("bonus-effects.enabled");
        if (totemBonusEffects) {
            this.bonusEffectApplyActions = new ObjectAction(section.getConfigurationSection("bonus-effects.apply-actions"));
            this.bonusEffectRemoveActions = new ObjectAction(section.getConfigurationSection("bonus-effects.remove-actions"));
            this.bonusEffectCircleActions = new ObjectAction(section.getConfigurationSection("bonus-effects.circle-actions"));
        }
        this.totemSection = section;
        ConfigurationSection totemLayoutsExplainConfig = section.getConfigurationSection("explains");
        if (totemLayoutsExplainConfig == null) {
            ErrorManager.errorManager.sendErrorMessage("§cError: Can not found any explains option in totem: " + id + ".");
            return;
        }
        Set<String> totemLayoutsExplainList = totemLayoutsExplainConfig.getKeys(false);
        Map<String, String> totemLayoutsExplain = new HashMap<>();
        for (String totemLayoutsChar : totemLayoutsExplainList) {
            if (totemLayoutsChar.length() > 1) {
                ErrorManager.errorManager.sendErrorMessage("§cError: Totem " + id + "'s layout explain config keys must be a char, like A.");
                return;
            }
            String totemLayoutsMaterial = totemLayoutsExplainConfig.getString(totemLayoutsChar);
            if (totemLayoutsMaterial == null) {
                totemLayoutsMaterial = "none";
            } else {
                totemLayoutsMaterial = totemLayoutsMaterial.toLowerCase();
            }
            totemLayoutsExplain.put(totemLayoutsChar, totemLayoutsMaterial);
        }
        ConfigurationSection layoutsSection = section.getConfigurationSection("layouts");
        if (layoutsSection != null) {
            ConfigManager.configManager.plus3DTotem();
            if (MythicTotem.freeVersion && ConfigManager.configManager.getThreeDtotemAmount() > 3) {
                ErrorManager.errorManager.sendErrorMessage("§cError: Free version" +
                        " can only create up to 3 3D totems, but your totem configs have more then 3 3D totems, please" +
                        " remove, otherwise plugin won't check 3D totems!");
                return;
            }
            Map<Integer, List<String>> totemLayouts = new HashMap<>();
            for (int i = 1 ; i <= layoutsSection.getKeys(false).size() ; i++) {
                if (!section.getStringList("layouts." + i).isEmpty()) {
                    totemLayouts.put(i, section.getStringList("layouts." + i));
                    this.totemLayer = i;
                } else {
                    break;
                }
            }
            for (int i = 1; i <= totemLayouts.size(); i++) {
                this.totemRow = 0;
                for (String s : totemLayouts.get(i)) {
                    for (this.totemColumn = 0; this.totemColumn < s.length(); this.totemColumn++) {
                        char realChar = s.charAt(this.totemColumn);
                        // realString 代表对应 layout 中对应 realChar 字节的 material
                        String realString = totemLayoutsExplain.get(String.valueOf(realChar));
                        // 放置到方块表中
                        // 插件的方块表是玩家放置方块时查询这个方块是否是图腾方块一部分使用的
                        if (totemCoreBlocks.isEmpty() || totemCoreBlocks.contains(String.valueOf(realChar))) {
                            if (ConfigManager.configManager.getTotemMaterial.containsKey(realString)) {
                                ConfigManager.configManager.getTotemMaterial.get(realString).add(
                                        new ObjectPlaceCheck(this,
                                                totemRow,
                                                totemColumn,
                                                i));
                            } else {
                                List<ObjectPlaceCheck> placedBlockCheckManagers = new ArrayList<>();
                                placedBlockCheckManagers.add(new ObjectPlaceCheck(this, totemRow, totemColumn, i));
                                ConfigManager.configManager.getTotemMaterial.put(realString, placedBlockCheckManagers);
                            }
                        }
                        this.totemLocationMaterial.put(generateID(i, totemRow, totemColumn), realString);
                    }
                    this.totemRow++;
                }
            }
            TextUtil.sendMessage(null, TextUtil.pluginPrefix() + " §fLoaded 3D Totem: §e" + totemID +
                    " §fwith size: " + totemRow + "x" + totemColumn);
        } else {
            List<String> totemLayout = section.getStringList("layout");
            this.totemRow = 0;
            for (String s : totemLayout){
                for (this.totemColumn = 0 ; this.totemColumn < s.length() ; this.totemColumn++){
                    char realChar = s.charAt(this.totemColumn);
                    // realString 代表对应 layout 中对应 realChar 字节的 material
                    String realString = totemLayoutsExplain.get(String.valueOf(realChar));
                    // 放置到方块表中
                    // 插件的方块表是玩家放置方块时查询这个方块是否是图腾方块一部分使用的
                    if (ConfigManager.configManager.getTotemMaterial.containsKey(realString)){
                        ConfigManager.configManager.getTotemMaterial.get(realString).add(new ObjectPlaceCheck(this, totemRow, totemColumn));
                    }
                    else{
                        List<ObjectPlaceCheck> placedBlockCheckManagers = new ArrayList<>();
                        placedBlockCheckManagers.add(new ObjectPlaceCheck(this, totemRow, totemColumn));
                        ConfigManager.configManager.getTotemMaterial.put(realString, placedBlockCheckManagers);
                    }
                    this.totemLocationMaterial.put(generateID(1, totemRow, totemColumn), realString);
                }
                this.totemRow++;
            }
            this.totemLayer = 1;
            TextUtil.sendMessage(null, TextUtil.pluginPrefix() + " §fLoaded 2D Totem: §e" + totemID +
                    " §fwith size: " + totemRow + "x" + totemColumn);
        }
        initEffects();
    }

    public void initEffects() {
        if (totemSection.getBoolean("bonus-effects.enabled", false) && totemSection.getBoolean("bonus-effects.effects.enabled", false)) {
            if (ConfigManager.configManager.getBoolean("libreforge-hook", false)) {
                LibreforgeEffects.libreforgeEffects.registerLibreforgeEffect(totemID);
            }
        }
    }

    private String generateID(int layer, int row, int column){
        return layer + ";;" + row + ";;" + column;
    }

    public int getRealRow(){
        return this.totemRow;
    }

    public int getRealColumn(){
        return this.totemColumn;
    }

    public String getRealMaterial(int layer, int row, int column){
        return totemLocationMaterial.get(layer + ";;" + row + ";;" + column);
    }

    public ObjectAction getTotemAction(){
        return this.totemAction;
    }

    public ObjectCondition getTotemCondition(){
        return this.totemCondition;
    }

    public boolean getTotemDisappear(){
        return this.totemDisappear;
    }

    public String getCheckMode() {
        return this.totemCheckMode;
    }

    public int getTotemLayer() {
        return this.totemLayer;
    }

    public ConfigurationSection getSection() {
        return this.totemSection;
    }

    public boolean getKeyMode() {
        return totemSection.getBoolean("prices-as-key", false);
    }
    
    public String getTotemID() {
        return totemID;
    }

    public void addBonusEffects(Block block, boolean isCore, UUID uuid) {
        if (!totemSection.getBoolean("bonus-effects.enabled", false)) {
            return;
        }
        if (this.totemDisappear) {
            ErrorManager.errorManager.sendErrorMessage("§cError: Bonus effects cannot active when your totem config " + totemID + ".yml setting disappear option to true!");
            return;
        }

        BonusEffectsManager.manager.addBonusEffectBlock(block, totemSection.getInt("bonus-effects.default-level", 1), totemID, isCore, uuid);
    }

    public double getBonusEffectsRange(BonusTotemData data) {
        double levelRange = totemSection.getDouble("bonus-effects.range." + data.level, -1.0);
        if (levelRange < 0) {
            double maxRange = totemSection.getDouble("bonus-effects.range.max", -1.0);
            if (maxRange < 0) {
                return totemSection.getDouble("bonus-effects.range", 10.0);
            }
            return maxRange;
        }
        return levelRange;
    }

    public boolean isBonusEffectsEnabled() {
        return totemBonusEffects;
    }

    public boolean checkAllBlocksAfterActive() {
        return totemDisappear || totemBonusEffects;
    }

    public void runBonusEffectsApplyActions(Player player, BonusTotemData data) {
        if (totemSection.getBoolean("bonus-effects.effects.enabled", false)) {
            TextUtil.sendMessage(null, TextUtil.pluginPrefix() + " §fStarted effect for player " + player.getName());
            mmoEffects.put(player.getUniqueId(), EffectUtil.startEffect(this, player, data));
        }
        bonusEffectApplyActions.runAllActions(player, data);
    }

    public void runBonusEffectsCircleActions(Player player, BonusTotemData data) {
        if (mmoEffects.get(player.getUniqueId()) != null) {
            mmoEffects.get(player.getUniqueId()).retryActiveEffects(data);
        }
        bonusEffectCircleActions.runAllActions(player, data);
    }

    public void runBonusEffectsRemoveActions(Player player, BonusTotemData data) {
        if (mmoEffects.get(player.getUniqueId()) != null) {
            for (AbstractEffect tempVal1 : mmoEffects.get(player.getUniqueId()).getActivedEffects()) {
                tempVal1.removePlayerStat();
            }
            mmoEffects.remove(player.getUniqueId());
        }
        bonusEffectRemoveActions.runAllActions(player, data);
    }
}
